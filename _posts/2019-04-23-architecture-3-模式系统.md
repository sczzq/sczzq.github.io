---
title: 模式简介一
date: 2019-04-22
categories:
- Tech
- patterns
tags:
- blog
- post
- patterns
---

> 适应环境，还是寻找环境，这是个问题。 --- 佚名

Pattern-Oriented Software Architecture  
Volume 1  

A System of Patterns  


模式有助于利用训练有素的软件工程师的集体经验，它们记录了软件开发领域已得到充分证明的既有经验，可帮助推广良好的设计实践。  

模式是由三部分组成的规则：特定背景、问题、解决方案，此三者之间的关系说明了模式的具体含义。  

> 模式的定义：  
软件架构模式描述了在特定设计情形下反复出现的设计问题，并提供了已得到充分证明的通用解决方案摘要。解决方案摘要描述模式的组件、组件的职责和关系，以及这些组件协作的方式。  

用途：  
着手进行粗粒度设计时，可使用架构模式，  
在整个设计阶段，都可以使用设计模式  
在实现阶段可使用成例  

## 架构模式  

> 架构模式的定义：  
架构模式描绘基本的软件系统组织纲要，提供了一组预定义的子系统，指出了这些子系统的职责，包含用于对子系统间关系进行组织的规则和指南。  

从另一个层面看，构建一个系统时，首先确定的是架构，  
对系统作粗粒度的划分，根据运行环境，职责划分，业务逻辑和性能指标，将系统分成几个子系统。  

典型的有一下几种模式，也即是子系统划分方式：  
- 分层  
- 管道和过滤器  
- 黑板  
- 中间人  
- 模型-视图-控制器  
- 表示-抽象-控制器  
- 微核  
- 反射  

每种模式适用于不同的场景。  
每种模式从不同角度对软件系统进行划分。  
比如，  
对于分布式系统，  
使用中间人模式对子系统进行划分。  
使用分层模式对模块的组件进行划分。  


对于语音识别系统，可分成服务层和识别层，  
服务层需要完成网络程序的事务，使得对外始终可以提供服务，  
服务层使用分布式中的Broker模式进行架构，  
此架构是针对于网络应用的一种实现方式，  
识别层需要完成语音识别的事务，使得每次的输入都有合适的输出产生。  
识别层使用黑板模式，输入是音频，输出是文字，  
那么，对于识别层，不需要关心有多少服务正在运行，也不需要关心服务的状态；对于服务层，不需要关心识别层是否可以给出正确结果，只需要在给定的时间内返回给客户端一个结果即可。  


### 从混乱到有序  

#### Layers  

将应用程序划分为多组子任务，每组子任务都位于特定抽象层。  

典型的有网络协议的分层架构，OSI七层模型。  
- 应用层，提供各种执行常见操作的协议  
- 表示层，组织信息并添加语义  
- 会话层，提供对话控制和同步功能  
- 传输层，将消息分拆成分组并提供传输保证  
- 网络层，选择从发送方前往接收方的路由  
- 数据链路层，发现并更正比特序列的错误  
- 物理层，传输比特：速度、比特码、连接等  

根据多种抽象准则，分层的例子：  
- 用户可看见的元素  
- 具体的应用程序模块  
- 通用服务层  
- 操作系统接口层  
- 操作系统  
- 硬件  

实现步骤：  
* 1, 定义抽象准则，使得任务划分到不同层  
* 2, 根据抽象准则确定抽象层级数  
* 3, 给每层命名并分派任务  
* 4, 规范服务  
* 5, 完善层次划分  
* 6, 规范每层的接口  
* 7, 确定各层的结构  
* 8, 规范相邻层的通信  
* 9, 将相邻层进行解耦  
* 10，制定错误处理策略  


#### Pipes and Filters  

此结构适用于处理数据流的系统。每个处理步骤都封装在一个过滤器组件中，数据通过相邻过滤器之间的管道传输。通过重组过滤器，可打造多个相关的系统族。  

包含的部分：  
- 过滤器  
- 管道  
- 数据源  
- 数据接收器  

实现步骤：  
* 1, 将系统要完成的任务划分为一系列处理阶段，每个阶段都只依赖于前一个阶段的输出。  
* 2, 定义沿管道传递的数据的格式。  
* 3, 确定如何实现每条管道的连接。  
* 4, 设计并实现过滤器。  
* 5, 设计错误处理机制。  
* 6, 搭建处理流水线。  

典型的实现实例：编译套件  
c/c++语言代码的编译步骤，  
大致分成四步：预处理，汇编，编译，链接。  
第一步的输入是文本文件，  
第一步的输出是第二步的输入，以此类推，  
最后一步的输出是可执行程序或者动态库，也即是可执行的二进制文件。  


#### Blackboard  

此模式对还未找到确定解决策略的问题很有帮助。可使用多个专业子系统进行综合判决，从而获得部分解或近似解。  

将问题的处理步骤分解成多个子问题的处理，而每个子问题都属于不同的专业领域。  

包含的部分：  
- 黑板组件  
- 一系列的知识源  
- 控制组件  

实现的步骤：  
* 1, 定义问题  
* 2, 定义问题的解空间  
* 3, 分解求解过程  
* 4, 根据子任务将知识划分为专业知识源  
* 5, 定义黑板的词表  
* 6, 规范系统的控制机制  
* 7, 实现知识源  

典型的实现实例：语音识别程序  
其中的知识源包含一些专业知识领域：声学，语音学，语言学，统计学  
每一个专业领域得出的结果可能是多个候选结果，  
使用控制组件和黑板组件进行候选结果的判定和结果的选取，  
以及决定是否是有效结果，以此来产生终止条件。  

### 分布式系统  

#### Broker  

Broker模式可用于设计这样的分布式软件系统，即包含通过远程服务调用进行交互的组件。一个中间人组件负责协调通信以及传递结果和异常。  

服务器向中间人注册，让客户端能够通过方法接口访问其服务。客户端通过中间人发送请求，以访问服务器的功能。中间人的任务包括找到合适的服务器、将请求转发给服务器以及将结果和异常传回给客户端。  

包含的部分：  
- 客户端  
- 服务器  
- 中间人  
- 网桥  
- 客户端代理  
- 服务器端代理  

实现步骤：  
* 1, 定义对象模型或使用现有模型  
* 2, 决定系统应提供什么样的组件互操作性，也即IDL，高级接口定义语言    
* 3, 制定中间人组件应向客户端和服务器端提供的API  
* 4, 使用代理对象对客户端和服务器隐藏实现细节  
* 5, 设计中间人组件  
* 6, 开发IDL编译器  

IDL：  
IDL编译器将IDL文件作为输入，生成编译语言代码或二进制代码。  
这些生成的代码中一部分是服务器所需，让服务器能够和本地中间人进行通信。  
一部分是客户端所需，让客户端能够和本地中间人通信。  

一些典型的实现：  
接口，负载，服务。  
客户端调用SDK和接口程序进行通信，  
接口程序向负载程序查询可用的服务程序，  
接口程序向服务程序发送请求，  
服务程序向接口程序发送结果，  
接口程序向客户端发送结果。  

改进型，请求和结果不通过中间人进行传输，  
中间人只向客户端代理发送服务端的连接信息，  
客户端代理直接和服务端进行请求和获取结果。  
这样可以减弱对接口的性能的需求。  

典型的实现实例：ceph的分布式特性即是客户端从监控程序处获取服务程序的信息后，直接和服务程序进行通信。  

典型的实现实例二：redis的哨兵模式，客户端连接redis之前先从redis-sentinel处获取一个可用地址，然后和redis进行直接通信。  

IDL的典型的实现：protobuf  
protobuf是一个协议消息格式，可以定义消息内容，然后编译生成消息处理代码，使得客户端和服务端直接进行消息内容的获取，而不需要专门写出对消息内容解析、生成、序列化的代码。  

IDL的典型的实现二：soap-webservice，可使用文本文件生成客户端和服务端代码，使得客户端可直接调用这些代码和服务端的通信。  

一个服务器可能提供多个服务，客户端可能需要具体的服务，也就是请求具体的服务，这时需要中间人了解每个服务器都有哪些服务，这样之后，中间人收到服务请求后，将请求发送给合适的服务器，或者告诉客户端一个合适的服务器。  

客户端传递消息类型，服务端根据消息类型确定需要执行的操作。  
客户端传递数据，服务端接收到数据后根据请求的接口执行操作。  
也就是操作由消息类型还是接口来确定。  

### 交互式系统  

交互式系统的核心取决于系统的功能性需求，通常比较稳定，  
而用户界面经常需要修改和调整。  

#### Model-View-Controller  

将交互式应用程序划分为三种组件：  
- 包含核心功能和数据的模型  
- 向用户显示信息的视图  
- 处理用户输入的控制器  

视图和控制器一起组成用户界面，变更传播机制确保用户界面和模型一致。  

实现步骤：  
* 1, 将人机交互与核心功能分离，  
* 2, 实现变更传播机制，  
* 3, 设计并实现视图，  
* 4, 设计并实现控制器，  
* 5, 设计并实现视图-控制器关系，  
* 6, 实现搭建MVC的代码，  
* 7, 动态的创建视图，  
* 8, ‘可插入式’控制器，
* 9, 创建视图和控制器层次结构，  
* 10，进一步降低系统的依赖性。  

#### Presentation-Abstraction-Control  

定义了一种适用于交互式软件系统的结构: 由相同协作的智能体组成的层次结构。  
每个智能体都负责应用程序功能的特定方面，  
并且每个智能体都包含三个组件：表示组件、抽象组件、控制组件，  
智能体内组件的划分使得智能体的人机交互方面同功能核心和通信方面分离了。  

实现步骤，必要时要重复：  
* 1, 定义应用程序模型，  
* 2, 制定PAC层次结构的总体组织策略，  
* 3, 确定顶层PAC智能体，  
* 4, 确定底层PAC智能体，  
* 5, 确定提供系统服务的底层PAC智能体，  
* 6, 确定用于组合下一层PAC智能体的中间PAC智能体，  
* 7, 确定用于协调底层智能体的中间PAC智能体，  
* 8, 将核心功能和人机交互分离，  
* 9, 提供外部接口，  
* 10，连接成层次结构。   

### 可适应系统  

随时间的推移，系统不断发生变化：添加新功能、修改既有服务。  
必须支持新版本的操作系统、用户界面平台、第三方组件和库。  

确保设计适应变化的模式。  

#### Microkernel  

适用于必须能够适应不断变化的需求的系统，它将最基本的功能核心与扩展的功能和随客户而异的部分分离。  
微核还充当插座，用于插入扩展和协调它们之间的协作。  

结构上包含：  
- 内部服务器  
- 外部服务器  
- 适配器  
- 客户端  
- 微核  



#### Reflection  




## 设计模式  

> 设计模式的定义：  
设计模式提供了对软件系统的子系统、组件或它们之间的关系进行改进的纲要，描述了对彼此通信的组件进行组织的常见结构，可解决特定背景下的一般性设计问题。  

设计模式处于的层次比架构模式小，比编程语言特定的模式大。  
使用设计模式不会影响软件系统的基本结构。  
会对子系统的架构带来重大影响。  

### 结构分解模式  

将子系统和组件分解成一系列相互协作的部分。  

#### Whole-Part  
有助于将组件聚合成语义整体。  
Whole组件封装组成它的Part组件，统筹它们之间的协作，并提供访问其功能的通用接口。从外部不能直接访问Part组件。  

包含的组件：  
- Whole   
- Part  

实现步骤：  
* 1, 设计Whole的公有接口，  
* 2, 将Whole划分为Part或使用现有对象来合成它，  
* 3, 如果采用自下而上的方式，从组件库或类库中选择现有Part，并确定它们如何协作。  
* 4, 如果采用自上而下的方式，将Whole的服务划分成相互协作的小服务，而这些服务将对应不同的Part。  
* 5, 使用Part的服务来定义Whole的服务。  
* 6，实现Part   
* 7, 实现Whole   


### 工作组织模式  

定义组件如何的协作，以解决复杂问题。  
Master-Slave模式，可组织必须能够容错或计算必须精确的服务，还有助于将服务划分成多个部分，这些部分彼此独立，可同时执行。   

组织复杂服务时，可遵循多个基本原则，如分离关注点、将策略和实现分离、采用分而治之的方法。  

Master-Slave遵循分而治之的原则，将工作分成多个分别处理的子任务，并根据每项处理操作的结果计算整个服务的结果。Master-Slave模式在并行和分布式计算领域得到广泛应用。  

Master-Slave模式的另一个实例是实现所谓的“三重模块冗余”原则。这种方法将服务的执行工作委托给三个独立组件，仅当至少有两个组件提供的结果相同时才认为结果有效。  

Chain of Responsibility模式，让多个对象都有机会处理请求，避免了将请求发送方和接收方挂钩。接收方被串联在一起，请求沿着链条不断传递，直到到达能够处理它的对象。  

Command模式，将请求封装成对象，让客户端能够利用参数发出不同的请求，还让你能够将请求排队或写入日志以及支持可撤销的操作。  

Mediator模式，定义了一个将对象的交互方式封装起来的对象。这个模式避免了对象彼此间引用，从而降低了耦合度，让你能够独立地修改对象之间的交互。  


#### Master-Slave  

在服务的客户端和子任务处理之间引入一个协调组件 --- 主组件。  
主组件将工作均分成多个子任务，将它们委托给多个独立但语义上相同的从组件，并根据从组件返回的部分结果计算最终结果。  

这些基本原则适用于三个应用领域：  
- 容错  
- 并行计算  
- 提高计算的准确度  

实现步骤：  
* 1, 分工  
* 2, 合并子任务的结果  
* 3, 规范主组件和从组件之间的协作  
* 4, 根据前一步制定的规范实现从组件  
* 5, 根据第1-3步制定规范实现主组件  

### 访问控制   

这类模式监视并控制对服务或组件的访问。  
比如Proxy模式，客户端能够与组件的代表通行。   
引入代理可以达到很多目的，如提高效率，简化访问，禁止未经授权的访问。  

Facade模式，提供了一个同一接口，用于访问子系统中的一组对象。  
Iterator模式，在不暴露聚合对象底层表示的情况下，提供了一种顺序访问其元素的方式。  

#### Proxy  

包含的组件：  
- 代理  
- 抽象原件  
- 原件  

实现步骤：  
* 1, 找出与组件访问控制相关的所有职责  
* 2, 如果可能，用一个抽象基类定义代理和原件接口都有的部分，并从这个抽象积累派生出代理和原件。  
* 3, 实现代理的函数  
* 4, 让原件和客户端不再承担已有代理承担的职责  
* 5, 在代理中包含一个指向原件的句柄，将代理和原件联系起来  
* 6, 消除客户端和原件的直接联系。  


### 管理模式  

这类模式处理一系列同质对象、服务和组件。  
Command Processor模式，管理和调度用户命令。  
View Handler，如何管理软件系统中的视图。  

#### Command Processor  

此模式将服务的请求和执行分开。命令处理器组件将请求作为独立的对象进行管理，调度其执行并提供额外服务，如存储请求对象以便以后能够撤销请求。  

包含的组件：  
- 命令处理器  
- 抽象命令  
- 控制器  
- 命令  
- 供应者  

如果需要实现命令撤销，那么执行命令前需要保存状态，  
状态变化有：新增，删除，修改。  
对于新增命令，保存的状态是新增，那么撤销命令时只需将命令产生的数据删除即可。  
对于删除命令，保存需要删除的数据，那么撤销时需要将删除的数据进行恢复。  
对于修改命令，保存修改前的数据，那么撤销时将数据恢复即可。  
同时，撤销也是一个命令，也需要保存撤销前的状态。  

数据库一般都支持事务处理，典型的有ACID，即：   
- 原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行  
- 一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。  
- 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其它事务的执行。  
- 持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。  

显然，如果一个事务包含多个命令，那么，后面命令执行失败需要撤销前面执行的命令。  


#### View Handler  

提供应用程序特定数据的多个视图或允许用户同时处理多个文档的软件系统，可以使用此模式。  

包含的组件：  
- 视图管理者  
- 抽象视图  
- 具体视图  


### 通信模式  

在分布式系统中，要降低组件和通信机制的耦合度，最重要的两个方面是封装和位置透明性。  

这类模式帮助统筹组件间通信。  
Forwarder-Receiver 致力于点对点通信，实现了封装。  
Client-Dispatcher-Server 描述了如何在客户端和服务器之间实现位置透明的通信。  

#### Forwarder-Receiver  

包含三种组件：  
- 转发者  
- 接收者  
- 对等体  

在执行任务时，对等体需要与其它对等体通信，而这些对等体可能位于其它进程或其它计算机中。每个对等体都知道与它通信的对等体的名称，使用转发者向其它对等体发送消息，并使用接收者接收来自其它对等体的消息。这种消息要么是对等体向远程对等体发送的请求，要么是对等体向请求对等体的发送的响应。  

实现步骤：  
* 1, 定义名称到地址映射  
* 2, 定义要在对等体和转发者之间使用的消息协议  
* 3, 选择通信机制  
* 4, 实现转发者  
* 5, 实现接收者  
* 6, 实现应用程序的对等体  
* 7, 实现启动配置  


#### Client-Dispatcher-Server  

### Publisher-Subscriber  

此模式有助于确保协作组件的数据一致。  
单向变更传播，发布者的状态发生变化时可通知任意数量的订阅者。  

Event Channel  
订阅者向事件通道进行注册，  
发布者也向事件通道注册   

事件通道的实现实例：消息总线，比如ZeroMQ，ActiveMQ, kafka, rabbitmq, rocketmq 等。    
此外，redis也实现了Publisher-Subscriber。  


## 成例  

> 成例的定义：  
成例是一种低层模式，针对的是特定编程语言。成例阐述如何使用给定语言的功能来实现组件或组件间关系的特定方面。  

致力于设计和实现方面。  

资源管理：Counted Pointer  


