---
title: Redis infomation
date: 2020-08-21
categories:
- Tech
- NoSQL
tags:
- blog
- post
---

> data structrue store.


Redis 是开源软件(BSD licensed)。  
基于内存的数据结构存储器，  
常用作数据库，缓存，消息代理。  
支持的数据结构：字符串，哈希表，链表，集合，排序集合，  
支持范围查询，位图，hyperloglogs, 地理离散数据索引，  
支持radius认证查询，流。  
支持复制、Lua脚本，LRU策略，事务，不同级别的硬盘持久化，  
支持高可用，实现方式：哨兵模式，集群自动分区。  
  
  
Pipelining，一次请求执行多条命令  
Pub/Sub，支持发布/订阅消息系统  
如何做的内存优化？  
过期，删除超出存在时长的键  
如何作为 LRU 缓存，使用固定内存大小，使得超时键值自动删除  
事务，将命令打包，作为一个事务  
客户端缓存，支持服务器辅助的客户端缓存  
大量数据的插入  
分区，如何将数据分布在多个实例中  
分布式锁，Redis 如何做分布式锁管理器  
创建二级索引  
  
  
安全  
访问控制  
代码安全，漏洞  
以外界恶意输入触发的攻击  
  
Redis被设计用来运行在信任环境中，  
	接收来自信任客户端访问  
所以，一般不将Redis访问接口暴露在公网下（不受信任的网络中）  
如果这么做，那么需要在客户端和Redis之间实现 ACL 层，  
用来鉴别输入，以及确定哪些操作可以执行。  
但是，如果运行在云服务器的虚拟化Linux实例中，  
Redis的访问端口必须设置成不可从外界访问，  
也即是说，运行在同一个Linux下的程序可以通过本地回环接口访问。  
  
保护模式  
触发方式：默认配置，没有设置密钥  
在这个模式下，只回复来自本地回环网口的查询。  
其它地址的连接只回复error  
  
认证特性  
Redis不实现访问控制，但提供简单的认证。  
可以在配置文件中打开认证。  
当认证打开，来自未认证的请求都会拒绝。  
客户端可以发送 AUTH psw 来执行认证。  
密钥以明文形式保存在配置文件中。  
  
AUTH命令，和其它命令一样，以明文形式在网络上传输。  
  
TLS 支持  
可选 TLS 支持，用来加密传输通道，  
包括客户端连接，复制连接，和集群总线协议。  
  
  
禁掉命令  
可以禁掉一些命令，也可以设置命令的别名，  
以此可以产生特殊命令访问集合  
使得客户端受限于这个集合  
  
攻击  
有一类攻击可以从外部触发，甚至不需要额外的权限。  
比如，可以构造数据，使得每次插入都触发最坏的算法复杂度  
比如，可以构造字符串，使得始终落入set中的同一个bucket  
	这样使得从平均O(1)期望时间一下子到了最坏的O(N)  
	消耗更多的CPU，最终可能导致拒绝服务  
	为了消除这个隐患，对于hash函数每个命令都使用一个伪随机种子  
比如，使用qsort实现SORT命令，但是当前没有使用随机化，  
	所以通过构造特定输入可以触发最坏的O(N^2)复杂度  
  
字符串转义和NoSQL注入  
Redis协议没有字符串转义的概念，  
所以在正常客户端库使用的正常场景中也可能出现注入。  
协议使用固定前缀长度字符串  
以及协议是完全二进制安全。  
Lua脚本使用相同的规则通过EVAL 和 EVALSHA命令执行，  
当有很奇怪的用例时，应用程序应当避免使用不信任来源的脚本字符串组成的执行体。  
  
代码安全  
在传统设置中，客户端可以完全访问所有命令集合。  
但是，实例的访问应该不应该在Redis正在运行时获得控制系统的能力。  
在内部，使用各种实践中的安全代码写法，  
避免内存溢出，格式化错误，其它内存崩溃问题  
  
但是，通过CONFIG命令可以使客户端有能力改变工作目录和dump文件名。  
所以，可以将RDB文件放在任何位置，这是一个安全问题。  
可以禁用CONFIG SET/GET dir命令  
Redis不需要root权限运行，推荐使用非特权redis用户，专门用于管理redis。  
  
  
SSL/TLS  
version 6 之后作为可选特性，需要在编译时使能此选项。  
  
  
内存优化  
小集合数据类型的特殊编码  
使用32位实例  
位和字节级别操作  
尽可能使用hash  
内存申请  
  
  
  
分布式锁  
分布式锁在很多场景中是有用的原语  
在这些场景中，多个进程需要独有的占用共享资源  
使用更标准的算法实现分布式锁。  
Redlock，比使用单实例更安全的DLM，分布式锁  
期望更多的使用反馈，以提供更好更复杂设计或者其它设计。  
  
安全性和存活保证  
给出三个属性，从作者观点，是有效性分布式锁的最小保证  
1, 安全属性，互斥锁，在任何场景中，只有一个客户端可以持有锁  
2，存活属性A，无死锁。总能获取一个锁，尽管持锁客户端崩溃或者划分到其它分区。  
3，存活属性B，容错。只要大多数REDIS节点运行着，客户端总能获取和释放锁。  
  
为什么故障切换不是必须的？  
为了理解想要增强的是什么，先分析一下当前的大多数基于REDIS分布式锁库关心的事务是什么  
最简单的使用方式  
通过创建一个键来对资源加锁，同时会使用到过期  
当客户端需要释放资源，就删除锁。  
如果超时了，锁也被删除了，通常因为客户端崩溃导致的超时。  
但是，有一个问题，架构中的单点故障问题。  
那么，加一个slave，当master不可用时就使用slave。  
可是这并不是可行的，不满足互斥锁属性，因为复制是异步的。  
  
  
高可用  
哨兵模式，作为高可用的官方方案。  
哨兵模式也可作其它任务，  
比如，监控，通知，配置客户端。  
哨兵模式的作用：  
1，Monitoring，监控，哨兵持续性检查主程序和复制程序正常工作  
2，Notification，通知，哨兵可以通知系统管理者，或者其它程序，  
   有监控程序出现问题  
3，Automatic failover，自动故障切换。如果主程序没有按期望工作，  
   哨兵开始执行故障切换过程，将备用程序提升为主程序，  
   其它的备用程序重新配置其主程序，客户端使用新的地址来连接服务器。  
4，Configuration provider，配置提供者。  
   哨兵作为客户端服务发现的认证源，客户端连接哨兵，  
   询问提供特定服务的Redis主程序的地址，  
   如果发生故障切换，哨兵提供新的地址。  
  
哨兵模式的分布式特性  
可以运行多个哨兵协同工作，有以下优势  
1，故障检测，需要多个哨兵确认，降低了假阳性，false positive  
2，少量哨兵程序出现问题，仍能提供哨兵服务，提高鲁棒性，  
   减少单点故障的影响  
  
2.8版本以后稳定。  
  
基本概念  
1，最少需要3个哨兵实例，才能满足最基本的鲁棒性部署  
2，这三个实例应当部署在相互独立的计算机或虚拟机上，  
   独立性是指它们的故障发生是不相互影响的，  
   比如，不同设备在不同的可用区，一个区出现问题，另一个区仍能正常  
3，哨兵分布式系统，不能保证在故障发生之后，  
   已确认写操作的数据仍然存在于系统中，因为使用异步复制。  
   但是，可以减少丢失窗口，  
4，需要在客户端支持哨兵  
5，没有HA设置是安全的，除非经常测试部署环境，或者生产环境  
6，哨兵，Docker，其它形式的网络地址翻译，端口映射，应当特别注意。  
典型配置，一主二备三哨兵，one master, two replica, three sentinel  
  
  
Quorum，仲裁数，只有超过这些数的哨兵同时确认，才能标记故障切换  
epochs，时代，每次仲裁使得时代增长，所有哨兵需要同步时代  
propagation，广播，以最大epochs的信息为准  
分区下的一致性  
哨兵状态的持久性，哨兵的状态会保存在磁盘上，所以哨兵重启是安全的  
TILT模式，时钟错误，或者其它导致的时钟错误，比如，被挂起，系统繁忙  
   定时器中断，每秒10次。  
   TILT模式是特殊的保护模式，当哨兵检测到降低系统可靠性事件，就会进入。  
   如果检测正常超过30秒，退出TILT模式。  
  
  
信号处理  
Redis如何处理POSIX的SIGTERM, SIGSEGV等信号。  
SIGTERM和SIGINT的处理  
这些信号告诉Redis优雅的关闭。  
当接收到这些信号时，服务器并不是马上关闭，  
而是将关闭命令插入到优先级最高的队列中，  
与SHUTDOWN命令相似  
队列中的关闭命令尽早执行，只要当前执行命令结束后就执行关闭命令  
有可能增加额外的0.1秒或更少的延迟  
  
当服务器被LUA脚本阻塞时间过长的时候，  
如果脚本是可使用SCRIPT KILL杀死的，那么队列的关闭命令在脚本杀死后马上执行，  
或者，就等待脚本执行完成自动退出后再执行关闭命令，  
  
这种情景下，关闭命令有这些行为：  
1，如果后台子线程正在保存RDB文件或执行AOF重写，子线程会被杀死  
2，如果存在AOF，Redis调用fsync系统命令，来flush AOF文件到磁盘  
3，如果配置了使用RDB文件做磁盘持久化，一个同步操作会执行。  
   但是，这个同步式保存操作不会使用更多的内存。  
4，如果是守护进程，文件描述符文件会被删除。  
5，如果有Unix域套接字，会被删除  
6，退出码是0，退出。  
  
如果RDB文件不能保存，那么关闭命令执行失败，  
服务器继续运行，为了保证没有数据丢失。  
不会再次处理这个信号，除非有新的信号到来。  
  
这些信号被认为Redis崩溃  
SIGSEGV, SIGBUS, SIGFPE, SIGILL  
如果陷入这些信号，Redis中止所有当前操作，执行以下行为：  
1，在日志文件中产生bug报告。包括栈轨迹，寄存器信息转存，客户端状态。  
2，2.8版本后，快速内存测试会执行，作为崩溃系统第一次可靠性测试  
3，如果是守护进程，文件描述符文件会被删除  
4，反注册信号句柄，发送给自己相同的信号，为了保证默认的操作被执行，  
   比如，转存核心文件到文件系统。  
  
当子进程被杀死会发生什么  
当执行AOF重写的子进程被信号杀死，Redis认为这是一个错误，  
丢弃（可能部分或全部的损坏）AOF文件。重写随后会被重新触发。  
当执行RDB保存的子进程被信号杀死，Redis大多数也会认为这是服务器错误，  
因为，缺少AOF文件重写的影响是AOF文件过大，  
而RDB文件创建失败的影响是丢失了持久化。  
如果创建RDB文件进程被信号杀死，或以错误方式退出，  
Redis进入特殊的错误条件，不再接收新的写命令  
1，Redis会继续接收读命令  
2，Redis以MSGCONFIG错误回复所有写命令。  
只要RDB文件被创建成功，那么错误条件就会被清除。  
  
如果用户需要杀死RDB进程，可以使用用户自定义信号，  
这样就不用触发上面的错误条件，  
服务器仍然继续提供正常请求。  
  
  
  
Redis latency monitoring framework  
延迟监控框架  
Redis通常运行在这样场景下，每个实例每秒接收大量请求  
并且有非常严格的延迟要求，包括平均响应时间和最坏延迟。  
Redis是内存系统，在不同操作系统的实现是不同的，  
特别的，它们的磁盘的持久化都是不同的。  
有丰富的命令集，有些命令是常数或对数时间复杂度，  
有些是一次多项式时间复杂度，这样就会产生了延迟突起  
Redis是单线程的，它可以提升单核效率，但是会增加延迟  
2.8.13之后，增加延迟监控，用来诊断和定位延迟问题。  
  
包含这些概念  
1，延迟钩子，在敏感代码路径进行取样  
2，时间序列，按照不同事件来记录延迟突起  
3，报告引擎，从时间序列中提取原始数据  
4，分析引擎，提供人类可读报告和分析  
  
延迟突起，高出期望延迟的部分。  
  
时间和时间序列  
根据不同的代码路径，划分为不同的事件  
比如，慢事件命令，一次多项式时间复杂度的命令代码路径  
快事件命令，常数或指数时间复杂度的代码路径  
还有其它事件，比如fork事件，记录调用fork(2)系统命令的执行时间  
  
  
  
  
  
  
  
  
  
  
  
  
