---
title: Redis infomation
date: 2020-08-21
categories:
- Tech
- NoSQL
tags:
- blog
- post
---

> data structrue store.


Redis 是开源软件(BSD licensed)。
基于内存的数据结构存储器，
常用作数据库，缓存，消息代理。
支持的数据结构：字符串，哈希表，链表，集合，排序集合，
支持范围查询，位图，hyperloglogs, 地理离散数据索引，
支持radius认证查询，流。
支持复制、Lua脚本，LRU策略，事务，不同级别的硬盘持久化，
支持高可用，实现方式：哨兵模式，集群自动分区。


Pipelining，一次请求执行多条命令
Pub/Sub，支持发布/订阅消息系统
如何做的内存优化？
过期，删除超出存在时长的键
如何作为 LRU 缓存，使用固定内存大小，使得超时键值自动删除
事务，将命令打包，作为一个事务
客户端缓存，支持服务器辅助的客户端缓存
大量数据的插入
分区，如何将数据分布在多个实例中
分布式锁，Redis 如何做分布式锁管理器
创建二级索引


安全
访问控制
代码安全，漏洞
以外界恶意输入触发的攻击

Redis被设计用来运行在信任环境中，
	接收来自信任客户端访问
所以，一般不将Redis访问接口暴露在公网下（不受信任的网络中）
如果这么做，那么需要在客户端和Redis之间实现 ACL 层，
用来鉴别输入，以及确定哪些操作可以执行。
但是，如果运行在云服务器的虚拟化Linux实例中，
Redis的访问端口必须设置成不可从外界访问，
也即是说，运行在同一个Linux下的程序可以通过本地回环接口访问。

保护模式
触发方式：默认配置，没有设置密钥
在这个模式下，只回复来自本地回环网口的查询。
其它地址的连接只回复error

认证特性
Redis不实现访问控制，但提供简单的认证。
可以在配置文件中打开认证。
当认证打开，来自未认证的请求都会拒绝。
客户端可以发送 AUTH psw 来执行认证。
密钥以明文形式保存在配置文件中。

AUTH命令，和其它命令一样，以明文形式在网络上传输。

TLS 支持
可选 TLS 支持，用来加密传输通道，
包括客户端连接，复制连接，和集群总线协议。


禁掉命令
可以禁掉一些命令，也可以设置命令的别名，
以此可以产生特殊命令访问集合
使得客户端受限于这个集合

攻击
有一类攻击可以从外部触发，甚至不需要额外的权限。
比如，可以构造数据，使得每次插入都触发最坏的算法复杂度
比如，可以构造字符串，使得始终落入set中的同一个bucket
	这样使得从平均O(1)期望时间一下子到了最坏的O(N)
	消耗更多的CPU，最终可能导致拒绝服务
	为了消除这个隐患，对于hash函数每个命令都使用一个伪随机种子
比如，使用qsort实现SORT命令，但是当前没有使用随机化，
	所以通过构造特定输入可以触发最坏的O(N^2)复杂度

字符串转义和NoSQL注入
Redis协议没有字符串转义的概念，
所以在正常客户端库使用的正常场景中也可能出现注入。
协议使用固定前缀长度字符串
以及协议是完全二进制安全。
Lua脚本使用相同的规则通过EVAL 和 EVALSHA命令执行，
当有很奇怪的用例时，应用程序应当避免使用不信任来源的脚本字符串组成的执行体。

代码安全
在传统设置中，客户端可以完全访问所有命令集合。
但是，实例的访问应该不应该在Redis正在运行时获得控制系统的能力。
在内部，使用各种实践中的安全代码写法，
避免内存溢出，格式化错误，其它内存崩溃问题

但是，通过CONFIG命令可以使客户端有能力改变工作目录和dump文件名。
所以，可以将RDB文件放在任何位置，这是一个安全问题。
可以禁用CONFIG SET/GET dir命令
Redis不需要root权限运行，推荐使用非特权redis用户，专门用于管理redis。


SSL/TLS
version 6 之后作为可选特性，需要在编译时使能此选项。


内存优化
小集合数据类型的特俗编码
使用32位实例
位和字节级别操作
尽可能使用hash
内存申请



分布式锁
分布式锁在很多场景中是有用的原语
在这些场景中，多个进程需要独有的占用共享资源
使用更标准的算法实现分布式锁。
Redlock，比使用单实例更安全的DLM，分布式锁
期望更多的使用反馈，以提供更好更复杂设计或者其它设计。

安全性和存活保证
给出三个属性，从作者观点，是有效性分布式锁的最小保证
1, 安全属性，互斥锁，在任何场景中，只有一个客户端可以持有锁
2，存活属性A，无死锁。总能获取一个锁，尽管持锁客户端崩溃或者划分到其它分区。
3，存活属性B，容错。只要大多数REDIS节点运行着，客户端总能获取和释放锁。

为什么故障切换不是必须的？
为了理解想要增强的是什么，先分析一下当前的大多数基于REDIS分布式锁库关心的事务是什么
最简单的使用方式
通过创建一个键来对资源加锁，同时会使用到过期
当客户端需要释放资源，就删除锁。
如果超时了，锁也被删除了，通常因为客户端崩溃导致的超时。
但是，有一个问题，架构中的单点故障问题。
那么，加一个slave，当master不可用时就使用slave。
可是这并不是可行的，不满足互斥锁属性，因为复制是异步的。















