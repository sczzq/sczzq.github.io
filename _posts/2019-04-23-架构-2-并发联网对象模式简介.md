---
title: 模式简介二
date: 2019-04-08
categories:
- Tech
- Patterns
tags:
- blog
- post
- patterns
---

Pattern-Oriented Software Architecture  
Volume 2  

Patterns for Concurrent and Networkded Objects  

## 服务访问和配置模式  

### Wrapper Facade  

将既有的非面向对象API提供的函数和数据封装到面向对象的类接口中  
使之更简介、更健壮、，可移植性、可维护性、内聚性更好。  

典型的有  
互斥体包装门面  
条件变量包装门面  
套接字包装门面  
线程包装门面  


### Component Configurator  

让应用程序可以在运行过程中加载和卸载组件，而无需修改、重新编译、和静态地重新链接应用程序。  
还支持将组件重新分配到其它进程中，而无需关闭或重启正在运行的进程。  

实现方式  
将组件的接口和实现分离，并让应用程序不依赖于组件的实现被加载到应用程序中。  

包含四个参与者  
- 抽象组件  
- 具体组件 
- 组件仓库  
- 组件配置程序  


### Interceptor  

使得可以透明地给框架添加服务，并在特定事件发生时自动触发他们。  

通过预定义的接口向框架注册“带外”服务，再让框架可从这个接口派生出具体拦截器。  
开放框架的实现，让带外服务能够访问和控制框架行为的某些方面。  


### Extension Interface  

可以使一个组件导出多个接口。  
当开发人员扩展或者修改组件的功能时，避免导致接口数目过多，或者破坏客户端的代码。  
包含四个参与者  
- 组件  
- 扩展接口  
- 客户端  
- 组件仓库  

扩展接口一般使用多重继承或者嵌套类来实现。  



## 事件处理模式  

发起、接收、分离、分派和处理事件。  

### Reactor  

别名：dispatcher, notifier

分离并分派一个或多个客户端发送到应用程序的服务请求。  

有五个参与者  
- 句柄  
- 同步事件分离程序  
- 事件处理程序  
- 具体事件处理程序  
- 反应器


### Proactor  

能够高效地分离和分派由异步操作完成而触发的服务请求，  
从而发挥并发的性能优势并且不会产生某些副作用。  

包含九个参与者  
- 句柄  
- 异步操作  
- 操作完成处理程序  
- 具体操作完成处理程序  
- 异步操作处理程序  
- 操作完成事件队列  
- 异步事件分离程序  
- 前摄器  
- 发起者  





### Asynchronous Completion Token  

使应用程序能够高效分离并处理对异步操作的响应，这些异步操作由应用程序在服务中调用。  
将操作完成事件分离到相应的操作完成处理程序中，其分离性能需随事件数目增加而线性上升。  

包含四个参与者  
- 服务  
- 发起者  
- 操作完成处理程序  
- ACT


### Acceptor-Connector  

在联网系统中，相互协作的端服务首先建立连接，完成初始化，然后进行相应处理。  
此模式将端服务的连接与初始化同之后的处理进行分离。  

包含六个参与者  
- 被动模式的传输端点  
- 传输句柄  
- 服务处理程序  
- 接收器  
- 连接器  
- 分派器  

## 同步模式  

用于简化并发系统中的锁操作。  

### Scoped Locking  

当控制代码进入到该作用域时，能够自动获取到锁。  
当控制代码离开该作用疆域时，能够自动释放锁。  

### Strategized Locking  

对组件中使用的同步机制进行参数化，保护对组件临界区的并发访问。  
通常使用Scoped Locking成例。  

### Thread-Safe Interface  

将锁的开销降到最低，并且确保组件内的方法调用不会导致‘自我死锁‘。  
自我死锁发生在试图重新获取组件已经持有锁的情况下。  

### Double-Checked Locking Optimization  

在程序执行时，每当代码的临界区需要以线程安全的方式只进行一次锁获取操作，  
此模式可以降低竞争和同步的开销。  

```c
if (!flag)
	lock
		if (!flag)
			do something
			set flag
	unlock
```

这样之后，只有一次加锁。  


## 并发模式  

描绘了不同的并发架构，解决了组件、子系统和应用程序的各种设计问题。  

### Active Object 模式  

将方法执行和方法调用分离，期望改善并发性、简化位于独立控制线程中的对象的同步访问。  

包含六个组件  
- 代理  
- 方法请求  
- 具体方法请求  
- 激活列表 
- 调度程序  
- 伺服程序  
- future  


### Monitor Object 模式  

同步并发的方法调用，确保每次只运行对象的一个方法，它还让对象的方法彼此协调，以安排他们的执行顺序。  


### Half-Sync/Half-Async 模式  

将并发系统的异步和同步服务处理分离，以简化编程工作，同时又不降低性能。  
它引入了两个相互通信的层，一层处理异步服务，一层处理同步服务。  

使适合同步操作的使用同步服务，使适合异步操作的使用异步服务。  

### Leader/Followers 模式  

提供了高效的并发模型，其中多个线程轮流检测一组事件源，对其发出的服务请求进行分离、分派和处理。  

参与者  
- 句柄集  
- 线程池  
- 事件处理程序  
- 具体事件处理程序  


### Thread-Specific Storage 模式  

让多个线程能够使用相同的’逻辑全局‘访问点来获取线程本地的对象，  
避免了每次访问对象的加锁的开销。  

所谓的无锁编程，  
初始化线程局部队列和计数器  
往线程局部队列中放入一个数据块，  
更新计数器  
通知线程有个事件到来  
线程根据当前计数和计数器来取出数据块  
线程访问数据块并进行操作  


