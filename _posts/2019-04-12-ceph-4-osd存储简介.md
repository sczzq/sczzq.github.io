---
title: ceph之osd存储简介
date: 2019-04-12
categories:
- Tech
- ceph
- storage
tags:
- blog
- ceph
- storage
---

> 落实，落实 --- 管理目标

primary osd收到客户端发送的数据后  
同一peering up set中的其它osd收到primary osd发送的数据后  
这些osd都需要将`数据`存储到`磁盘`中  

osd调用存储模块来保存数据。  

## 存储类  

存储模块接口是 ObjectStore  

ObjectStore 是接口类，也是工厂类  

作为工厂，用于生产具体的存储类  
具体存储类是 ObjectStore 的子类  
当前的具体类有 FileStore, MemStore, BlueStore, KStore

作为接口，ObjectStore封装存储引擎的所有IO操作  
并向上层提供对象、事务语义的接口  

有两种存储数据  
一个是 journal  
一个是 object  
这两种是都需要保存到磁盘中。

日志是用于实现事务处理能力。  
数据库的事务性包含：原子性，一致性，隔离性，持久性。  


journal 事务相关的数据  
object 对象相关的数据  

### 对象内容和语义  

所有的 ObjectStore 的对象都是以命名对象存在于命名集合中的  
ObjectStore操作支持：  
- 创建  
- 修改  
- 删除  
- 集合中对象的枚举  
枚举是按照关键字的顺序的，关键字是以hash值进行排序的  
对象名是全局唯一的  

每个对象有四个不同的部分：字节数据，属性，映射表头，映射表项  

对象的数据部分从概念上和文件系统的文件是相同的。  
随机和部分的读写操作是必须的。  
数据部分的稀疏存取的实现在某些工作场景中是有好处的，但不是必须的。  
数据的最大值有一个系统级别的限制，典型值是 100MB。  

属性相当于文件系统中的扩展属性。  
属性的保存方式是 std::set 的 key/value 对。  
子值的访问不是必须的。  
可能需要按照key的顺序枚举std::set。  
在实现上，属性主要在内部使用，而且实现者期望一个对象的所有属性的总大小要相对的小，比如，小于64KB。ceph的很多部分假设对临时相邻对象的属性的访问的代价不是高昂的。  

映射表头是数据的单独的部分。它可以作为整体的读写。  

映射表项从概念上和属性是一样的，只不过保存在不同的地址空间。  
也就是说，你可以将相同的key分别以不同的值保存在属性和映射表项中。  
对属性的枚举不包含映射表项的枚举，反过来也是。  
映射表项的大小和访问特征和属性是截然不同的。  
特殊的，映射表项的数据部分可以很大，比如，数MB。  
更重要的是，接口必须支持高效的范围查找，尽管有大量的表项。  

### 集合  

一个集合仅仅是多个对象的组。  
集合也有名字，可以按照顺序枚举。  
就像单独的对象，一个集合也有一个std::set的属性。  

### 事务  

事务是原生性修改操作的序列。  
也就是，一个事务包含多个原生性修改操作。  

事务的生命周期中有三个回调。  
任意事务包含任意个回调类的任意个回调对象。  
也就是说，一个事务可能包含任意个回调对象，而其中的回调对象可能是三个回调类的其中任意一个。  
也就是说，一个事务中包含三个回调类的对象的任意的组合。  
回调类有三个，on_applied_sync, on_applied, on_commit   

on_applied 和 on_applied_sync 回调  
当事务的修改操作对后续的ObjectStore操作是可见的时候，调用这两个回调。  
也就是说，结果是可读的。  
在on_applied和on_applied_sync之间的概念上的不同是回调函数操作所在的特定的线程和加锁环境，  
on_applied_sync由ObjectStore执行线程直接调用。  
所以，期望它非常快的执行，并且不能申请调用者环境中的任意的锁。  
相反，on_applied从一个另外的完成线程来调用，也就是它可能包含调用环境中的锁。  
另外，on_applied和on_applied_sync有时分别调用on_readable和on_readalbe_sync。  

on_commit调用也是从完成线程中调用，用来指示所有的改变都已经提交到稳定存储设备中。  

在实现中，每一个改变原语，包括它的关联数据，都可以序列化到一个单独内存中。  
但是，这个序列化没有任何拷贝。  
而是引用原有内存。  
这些暗示着，已经提交到执行on_commit之间，这块内存必须保持不变。  
在实践中，ceph::buffer::list处理这些东西。  

一些ObjectStore的实现选择使用事务序列化格式来实现他们自己的不同的日志表格   


### 事务隔离  

不像前面描述，隔离是由调用者来保证的。  
也就是说，如果任何的存储元素被一个事务改变，  
当这个事务处于待决状态中，调用者保证不去尝试读取这个元素，  
所谓待决状态是指，从提交事务到on_applied_sync回调接收之间的。  
违反隔离需求不会被ObjestStore检测，  
也没有相应的错误检测机制用来报告隔离违反。  
崩溃可能是恰当的方式，用来报告隔离违反被检测到了。  

枚举操作可能违反事务隔离，  
当一个事务中包含存储元素被创建或删除时。  
在这种情形下，ObjectStore允许枚举操作先于或后于隔离性的事务操作元素。  
也就是说，可变元素的存在和不存在完全由ObjectStore自主决定的。  
可以有任意的组合顺序，并且和事务元素不相关。  
比如，如果一个事务包含两个可变操作， create A 和 delete B，  
一个枚举操作在此事务处于待决过程中执行，  
那么，ObjectStore允许A和B的存在性的四种组合都是可能的。  



## 存储引擎  

### FileStore  

FileStore使用文件系统的POSIX接口来实现对象的存取。  
每个对象都对应文件系统中的一个文件。  
而日志信息保存到单独的文件中，  
对于此存储引擎来说，对象是异步写，日志是同步写的。  
对象的属性使用文件系统中文件的属性进行存取。  


### BuleStore  

直接管理物理磁盘设备  
在用户态进行磁盘IO操作  
存储空间分配器：Stupid Allocator, Bitmap Allocator  
日志数据直接保存于磁盘上  
对象的原始数据直接保存于磁盘上  
对象的元数据以KV的方式保存在RocksDB中  
RocksDB的操作建立于BlueFS  
BlueFS是建立于磁盘上的一个小的文件系统  


## 术语  
对象 -- Object  
集合 -- Collection  
事务 -- Transaction  
原生性 -- Primitive  
改变操作 -- mutation operation  

------
Reference  
1, https://github.com/ceph/ceph/blob/master/src/os/ObjectStore.h
2, http://docs.ceph.com/docs/master/dev/object-store/
3, https://blog.csdn.net/BtB5e6Nsu1g511Eg5XEg/article/details/81740919
