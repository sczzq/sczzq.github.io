---
title: 模式简介三
date: 2019-04-25
categories:
- Tech
- Patterns
- resource management
tags:
- blog
- post
- patterns
- resource management
---

> 坐稳，起飞。

Pattern-Oriented Software Architecture  
Volume 3  

Patterns for Resource Management  

## 简介  

### 参与者  

资源是一种实体，并且是有限的。  

资源用户可以是任何获取、访问或释放资源的实体。  

资源管理涵盖以下几个方面：  
- 确保资源在需要时可用  
- 确保资源的生命周期是确定的  
- 确保资源及时得到释放  

### 作用力  

设计高效资源管理的系统时，需要考虑以下作用力：  
- 性能  
- 可扩展性  
- 可预测性  
- 灵活性  
- 稳定性  
- 一致性  

### 资源管理模式：  

对于性能，  
Eager Acquisition模式，通过提前获取资源，加快使用时资源的访问速度。  
Caching模式，Pooling模式，通过缓存或资源池管理，减少资源申请和释放的时间。  

对于可扩展性：  
Leasing模式和Evictor模式，合理规划释放资源的时机，降低资源使用率和不足的风险。  
Coordinator模式，降低了系统参与者增多带来的可扩展性。  
Caching模式，Pooling模式，通过缓存或资源池管理，也能增强扩展性。    
Lazying Acquisition模式和Partial Acquisition模式确保实际需要资源时才获取它们，减少特定时间点资源的占用数。  
Resource Lifecycle Manager模式，用于管理资源的生命周期，也能增强可扩展性。  

对于可预测性：  
Eager Acquisition模式，提前申请资源，可保证访问资源的时间是固定的，增加了系统的可预测性。  
Pooling模式，同样，也增加了可预测性。  

对于灵活性：  
Lookup模式，消除了资源提供方和资源使用方的紧密联系，增加了系统的灵活性，也增加了可扩展性。  
Partial Acquisition模式和Lazy Acquisition模式，可使用不同的申请策略，也增加了灵活性。  

对于稳定性：  
Lazy Acquisition模式和Eager Acquisition模式，减小特定时间点资源消耗，有助于稳定性。  
Pooling模式，避免了频繁的底层操作，有助于稳定性。  
Evictor模式，寻找合适时机释放资源，有助于稳定性。  
Leasing模式，减少未使用资源的占用，有助于稳定性。  
Resource Lifecycle Manager模式，可确保资源充足时才给用户分配资源，有助于系统稳定性。  

对于一致性：  
Coordinator模式，通过协调协商资源状态，有助于保持资源的一致性。  


### 简单说明  

关于资源管理，从硬件到内核，到用户空间，每一层都在做资源管理，包括申请，使用，释放。而内核即是管理整个计算机硬件资源，并提供接口让用户程序可以使用。   

举个例子  
网络数据到达网卡后，网卡会产生内核中断，通知内核有数据到来  
同时，网卡会接收一些数据，这些数据保存在网卡的内存空间中  
而这个内存空间可以直接映射到内核的主存空间，简称内核空间。  
内核解析数据包，确定数据包中的数据的接收实体和数据部分，  
如果没有接收数据的实体存在，就直接把数据包丢掉；  
如果有接收数据的实体存在，而此实体一般需要在用户空间进行数据的解析，  
所以接收实体需要将数据从内核空间中读取到用户空间中。  
那么，如果内核空间中保存数据的内存空间用完了，会出现数据包丢失的现象。  
这时，产生一个性能瓶颈，属于I/O性能瓶颈，也可能归属于CPU性能瓶颈。  

在这里，使用的模式有Eager Acquisition，Pooling，  
也就是网卡使用的内存资源是提前申请的，  
并将内存资源放到资源池。  

所谓的高性能，在资源管理部分，是减小资源的使用量，减小资源获取释放的时间  
比如，内存申请，  
如果使用malloc做内存申请，需要执行malloc的实现的代码，  
而在实现中通常有一部分的内存管理，可能也会执行系统调用，以向内核申请内存，  
而内核作为最终的内存管理者，需要处理非常多的内存管理事件，需要保证全局状态的一致性，  
同时也牵涉到用户空间到内核空间的切换，所以，这部分可能是非常耗时。  
减小耗时的操作，就是先申请一块大的，减小对malloc的调用，甚至减小系统调用，  
而在自己的空间进行简单的内存管理。  
也是一种分级管理思想。  
不好的地方就是，申请的永远比使用的多。  

在实际实现中，往往是多级缓存。  
也和系统的分层划分有关。  
从上到下的各层分别为：  
用户程序  
库  
内核  
硬件驱动  

首先硬件驱动会有缓存，数据可以直接缓存在硬件上，也可以映射到内核的内存空间中，  
内核也有缓存，对各种数据的读写传输，内核也会对数据做处理，也需要缓存  
库也有缓存，为了减少对内核接口的频繁调用，减小进程状态切换，也需要缓存  
用户程序也会有缓存，如果管理机制很简单就能达到目标，那么库实现的缓存可能也是一个性能优化的地方，就是用户程序接管一些资源的管理。  


### 模式使用场景简述  

不同的模式有不同的实现使用，这里简单说明一些模式的实际使用场景：  

#### Lookup  

作为资源获取中的模式，已知应用：  
- CORBA，公共对象服务    
- LDAP，轻型目录访问协议  
- JNDI，Java命令和目录接口  
- Jini，自组网协议，jini服务向jini查找服务注册，jini查找服务定期广播自己的存在  
- COM+，Windows注册表是一项查找服务  
- UDDI，统一描述、发现和集成协议  
- 点对点网络，通告和发现对象体，比如jxta  
- DNS，域名服务，负责域名与IP地址间的协调和映射  
- 网格计算，共享和聚合分布式资源。  
- Eclipse插件注册表  
- 电话薄服务  
- 总机  

#### Lazy Acquisition  

作为资源获取中的模式，已知应用：  
- 操作系统，库加载，延迟加载，使用时加载  

#### Eager Acquisition  

作为资源获取中的模式，已知应用：  
- Pooling，连接池和线程池，通常需要先获取大量资源  

#### Partial Acquistion  

作为资源获取中的模式，已知应用：  
- 逐步加载图像，浏览器中，先下载并显示文字内容，而后下载图像并逐步显示图像。  
- 套接字传输，从套接字读数据，通常是Partial Acquisition的，由于套接字中可能没有全部的数据，需要多次读取，每次从套接字中读取部分数据，所有数据都会出现在缓存中。  
- 音频/视频流，对音频和视频流解码时，分多次获取一个帧或多个帧，在解码、缓冲、显示这些帧。  

#### Caching  

作为资源生命周期中的模式，已知应用：  
- 硬件缓存，几乎所有的处理器都有硬件缓存  
- 文件系统和分布式文件系统中的缓存，内存缓存避免总是从磁盘读取数据，客户端内存或磁盘缓存避免总是从服务端获取数据。    
- 数据传输对象，远程调用时使用按值传输的方式  
- Web代理，Web浏览器先访问Web代理，Web代理再向Web服务器访问网页，而后Web代理将网页进行缓存，下次再次访问同一地址时，直接返回缓存网页，前提是网页没有发生更新。  
- Web浏览器，大多数浏览器都将用户访问的网页缓存到本地。浏览器使用事件戳决定在缓存中保留网页多久以及何时将其删除。  
- 换页，现代操作系统都将页面留在内存中，避免从磁盘交换空间中读取而带来的开销。仅当页面在内存中找不到时，才从磁盘读取。  
- 文件缓存  

#### Pooling  

作为资源生命周期中的模式，已知应用：  
- Connection Pooling，连接池
- Thread Pooling，线程池  
- Component Instance Pooling，预先实例化数量有限的常用组件，以迅速满足最初的需求。  
- Pooled Allocation，预先分配一系列不同大小的内存块序列，放到内存池中，同时循环利用归还的内存块。  
- Object Pooling，管理特定对象的循环利用。  

#### Coordinator  

作为资源生命周期中的模式，已知应用：  
- Java身份验证和授权服务  
- 事务服务  
- 数据库，使用Coordinator模式和两阶段提交协议。  
- 软件安装，在准备阶段执行检查，确保安装任务能够顺利进行。  


